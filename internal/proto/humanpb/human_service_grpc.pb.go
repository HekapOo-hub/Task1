// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package humanpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HumanServiceClient is the client API for HumanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HumanServiceClient interface {
	CreateHuman(ctx context.Context, in *Human, opts ...grpc.CallOption) (*Empty, error)
	UpdateHuman(ctx context.Context, in *UpdateHumanRequest, opts ...grpc.CallOption) (*Empty, error)
	GetHuman(ctx context.Context, in *Name, opts ...grpc.CallOption) (*Human, error)
	DeleteHuman(ctx context.Context, in *Name, opts ...grpc.CallOption) (*Empty, error)
	Authenticate(ctx context.Context, in *SignInRequest, opts ...grpc.CallOption) (*Tokens, error)
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*Empty, error)
	GetUser(ctx context.Context, in *Login, opts ...grpc.CallOption) (*User, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*Empty, error)
	DeleteUser(ctx context.Context, in *Login, opts ...grpc.CallOption) (*Empty, error)
	Refresh(ctx context.Context, in *Tokens, opts ...grpc.CallOption) (*Tokens, error)
	LogOut(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	DownloadFile(ctx context.Context, opts ...grpc.CallOption) (HumanService_DownloadFileClient, error)
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (HumanService_UploadFileClient, error)
}

type humanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHumanServiceClient(cc grpc.ClientConnInterface) HumanServiceClient {
	return &humanServiceClient{cc}
}

func (c *humanServiceClient) CreateHuman(ctx context.Context, in *Human, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/CreateHuman", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) UpdateHuman(ctx context.Context, in *UpdateHumanRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/UpdateHuman", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) GetHuman(ctx context.Context, in *Name, opts ...grpc.CallOption) (*Human, error) {
	out := new(Human)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/GetHuman", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) DeleteHuman(ctx context.Context, in *Name, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/DeleteHuman", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) Authenticate(ctx context.Context, in *SignInRequest, opts ...grpc.CallOption) (*Tokens, error) {
	out := new(Tokens)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/Authenticate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) GetUser(ctx context.Context, in *Login, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) DeleteUser(ctx context.Context, in *Login, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) Refresh(ctx context.Context, in *Tokens, opts ...grpc.CallOption) (*Tokens, error) {
	out := new(Tokens)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/Refresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) LogOut(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/protobuf.HumanService/LogOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *humanServiceClient) DownloadFile(ctx context.Context, opts ...grpc.CallOption) (HumanService_DownloadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &HumanService_ServiceDesc.Streams[0], "/protobuf.HumanService/DownloadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &humanServiceDownloadFileClient{stream}
	return x, nil
}

type HumanService_DownloadFileClient interface {
	Send(*Name) error
	Recv() (*FilePortion, error)
	grpc.ClientStream
}

type humanServiceDownloadFileClient struct {
	grpc.ClientStream
}

func (x *humanServiceDownloadFileClient) Send(m *Name) error {
	return x.ClientStream.SendMsg(m)
}

func (x *humanServiceDownloadFileClient) Recv() (*FilePortion, error) {
	m := new(FilePortion)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *humanServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (HumanService_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &HumanService_ServiceDesc.Streams[1], "/protobuf.HumanService/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &humanServiceUploadFileClient{stream}
	return x, nil
}

type HumanService_UploadFileClient interface {
	Send(*Name) error
	Recv() (*Empty, error)
	grpc.ClientStream
}

type humanServiceUploadFileClient struct {
	grpc.ClientStream
}

func (x *humanServiceUploadFileClient) Send(m *Name) error {
	return x.ClientStream.SendMsg(m)
}

func (x *humanServiceUploadFileClient) Recv() (*Empty, error) {
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HumanServiceServer is the server API for HumanService service.
// All implementations must embed UnimplementedHumanServiceServer
// for forward compatibility
type HumanServiceServer interface {
	CreateHuman(context.Context, *Human) (*Empty, error)
	UpdateHuman(context.Context, *UpdateHumanRequest) (*Empty, error)
	GetHuman(context.Context, *Name) (*Human, error)
	DeleteHuman(context.Context, *Name) (*Empty, error)
	Authenticate(context.Context, *SignInRequest) (*Tokens, error)
	CreateUser(context.Context, *CreateUserRequest) (*Empty, error)
	GetUser(context.Context, *Login) (*User, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*Empty, error)
	DeleteUser(context.Context, *Login) (*Empty, error)
	Refresh(context.Context, *Tokens) (*Tokens, error)
	LogOut(context.Context, *Empty) (*Empty, error)
	DownloadFile(HumanService_DownloadFileServer) error
	UploadFile(HumanService_UploadFileServer) error
	mustEmbedUnimplementedHumanServiceServer()
}

// UnimplementedHumanServiceServer must be embedded to have forward compatible implementations.
type UnimplementedHumanServiceServer struct {
}

func (UnimplementedHumanServiceServer) CreateHuman(context.Context, *Human) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateHuman not implemented")
}
func (UnimplementedHumanServiceServer) UpdateHuman(context.Context, *UpdateHumanRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHuman not implemented")
}
func (UnimplementedHumanServiceServer) GetHuman(context.Context, *Name) (*Human, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHuman not implemented")
}
func (UnimplementedHumanServiceServer) DeleteHuman(context.Context, *Name) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteHuman not implemented")
}
func (UnimplementedHumanServiceServer) Authenticate(context.Context, *SignInRequest) (*Tokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedHumanServiceServer) CreateUser(context.Context, *CreateUserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedHumanServiceServer) GetUser(context.Context, *Login) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedHumanServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedHumanServiceServer) DeleteUser(context.Context, *Login) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedHumanServiceServer) Refresh(context.Context, *Tokens) (*Tokens, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedHumanServiceServer) LogOut(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogOut not implemented")
}
func (UnimplementedHumanServiceServer) DownloadFile(HumanService_DownloadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedHumanServiceServer) UploadFile(HumanService_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedHumanServiceServer) mustEmbedUnimplementedHumanServiceServer() {}

// UnsafeHumanServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HumanServiceServer will
// result in compilation errors.
type UnsafeHumanServiceServer interface {
	mustEmbedUnimplementedHumanServiceServer()
}

func RegisterHumanServiceServer(s grpc.ServiceRegistrar, srv HumanServiceServer) {
	s.RegisterService(&HumanService_ServiceDesc, srv)
}

func _HumanService_CreateHuman_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Human)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).CreateHuman(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/CreateHuman",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).CreateHuman(ctx, req.(*Human))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_UpdateHuman_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHumanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).UpdateHuman(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/UpdateHuman",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).UpdateHuman(ctx, req.(*UpdateHumanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_GetHuman_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).GetHuman(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/GetHuman",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).GetHuman(ctx, req.(*Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_DeleteHuman_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Name)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).DeleteHuman(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/DeleteHuman",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).DeleteHuman(ctx, req.(*Name))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/Authenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).Authenticate(ctx, req.(*SignInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).GetUser(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Login)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).DeleteUser(ctx, req.(*Login))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tokens)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/Refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).Refresh(ctx, req.(*Tokens))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_LogOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HumanServiceServer).LogOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobuf.HumanService/LogOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HumanServiceServer).LogOut(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _HumanService_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HumanServiceServer).DownloadFile(&humanServiceDownloadFileServer{stream})
}

type HumanService_DownloadFileServer interface {
	Send(*FilePortion) error
	Recv() (*Name, error)
	grpc.ServerStream
}

type humanServiceDownloadFileServer struct {
	grpc.ServerStream
}

func (x *humanServiceDownloadFileServer) Send(m *FilePortion) error {
	return x.ServerStream.SendMsg(m)
}

func (x *humanServiceDownloadFileServer) Recv() (*Name, error) {
	m := new(Name)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _HumanService_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HumanServiceServer).UploadFile(&humanServiceUploadFileServer{stream})
}

type HumanService_UploadFileServer interface {
	Send(*Empty) error
	Recv() (*Name, error)
	grpc.ServerStream
}

type humanServiceUploadFileServer struct {
	grpc.ServerStream
}

func (x *humanServiceUploadFileServer) Send(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *humanServiceUploadFileServer) Recv() (*Name, error) {
	m := new(Name)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HumanService_ServiceDesc is the grpc.ServiceDesc for HumanService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HumanService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protobuf.HumanService",
	HandlerType: (*HumanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHuman",
			Handler:    _HumanService_CreateHuman_Handler,
		},
		{
			MethodName: "UpdateHuman",
			Handler:    _HumanService_UpdateHuman_Handler,
		},
		{
			MethodName: "GetHuman",
			Handler:    _HumanService_GetHuman_Handler,
		},
		{
			MethodName: "DeleteHuman",
			Handler:    _HumanService_DeleteHuman_Handler,
		},
		{
			MethodName: "Authenticate",
			Handler:    _HumanService_Authenticate_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _HumanService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _HumanService_GetUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _HumanService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _HumanService_DeleteUser_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _HumanService_Refresh_Handler,
		},
		{
			MethodName: "LogOut",
			Handler:    _HumanService_LogOut_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DownloadFile",
			Handler:       _HumanService_DownloadFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadFile",
			Handler:       _HumanService_UploadFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "human_service.proto",
}
